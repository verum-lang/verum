(* ============================================================================ *)
(* Verum Language Complete EBNF Grammar                                         *)
(* Version: 1.0                                                                 *)
(* Last Updated: 2025-11-15                                                     *)
(* Status: Production-Ready - Formal Specification                              *)
(* ============================================================================ *)

(* ============================================================================ *)
(* 1. LEXICAL GRAMMAR                                                           *)
(* ============================================================================ *)

(* 1.1 Whitespace and Comments *)
whitespace      = ' ' | '\t' | '\r' | '\n' ;
line_comment    = '//' , { char_except_newline } , '\n' ;
block_comment   = '/*' , { char_except_star_slash } , '*/' ;
comment         = line_comment | block_comment ;

(* 1.2 Character Classes - Fully Specified *)
(* Unicode categories as per Unicode Standard *)
unicode_letter  = '\u0041'..'\u005A' | '\u0061'..'\u007A'
                | '\u00C0'..'\u00D6' | '\u00D8'..'\u00F6'
                | '\u00F8'..'\u02FF' | '\u0370'..'\u037D'
                | '\u037F'..'\u1FFF' | '\u200C'..'\u200D'
                | '\u2070'..'\u218F' | '\u2C00'..'\u2FEF'
                | '\u3001'..'\uD7FF' | '\uF900'..'\uFDCF'
                | '\uFDF0'..'\uFFFD' ;

unicode_digit   = '\u0030'..'\u0039' | '\u0660'..'\u0669'
                | '\u06F0'..'\u06F9' | '\u07C0'..'\u07C9'
                | '\u0966'..'\u096F' | '\u09E6'..'\u09EF'
                | '\u0A66'..'\u0A6F' | '\u0AE6'..'\u0AEF' ;

(* ASCII subset for common use *)
ascii_letter    = 'a'..'z' | 'A'..'Z' ;
ascii_digit     = '0'..'9' ;

(* Composite character classes *)
lowercase_letter= 'a'..'z' ;
uppercase_letter= 'A'..'Z' ;
letter          = ascii_letter | unicode_letter ;
digit           = ascii_digit | unicode_digit ;

(* Special character sequences *)
char_except_newline     = '\u0000'..'\u0009' | '\u000B'..'\u000C' | '\u000E'..'\uFFFF' ;
char_except_star_slash  = '\u0000'..'\u0029' | '\u002B'..'\uFFFF' | ( '*' , char_except_slash ) ;
char_except_slash       = '\u0000'..'\u002E' | '\u0030'..'\uFFFF' ;
char_except_quote       = '\u0000'..'\u0021' | '\u0023'..'\u005B' | '\u005D'..'\uFFFF' ;
char_except_apostrophe  = '\u0000'..'\u0026' | '\u0028'..'\u005B' | '\u005D'..'\uFFFF' ;
char_except_backslash   = '\u0000'..'\u005B' | '\u005D'..'\uFFFF' ;

(* 1.3 Identifiers *)
ident_start     = letter | '_' ;
ident_continue  = letter | digit | '_' ;
identifier      = ident_start , { ident_continue } ;
type_param_name = uppercase_letter , { ident_continue } ;

(* 1.4 Keywords *)

(* Core reserved keywords - ONLY 3 *)
reserved_keyword = 'let' | 'fn' | 'is' ;

(* Primary keywords *)
primary_keyword = 'type' | 'where' | 'using' ;

(* Control flow keywords *)
control_flow = 'if' | 'else' | 'match' | 'return'
             | 'for' | 'while' | 'loop' | 'break' | 'continue' ;

(* Async/Context keywords *)
async_keywords = 'async' | 'await' | 'spawn' | 'defer' | 'try' | 'yield' ;

(* Modifier keywords *)
modifiers = 'pub' | 'mut' | 'const' | 'unsafe' ;

(* FFI keywords *)
ffi_keywords = 'ffi' ;

(* Module keywords *)
module_keywords = 'module' | 'import' | 'implement' | 'context' | 'protocol' ;

(* Additional keywords *)
additional_keywords = 'self' | 'super' | 'crate' | 'static' | 'meta'
                    | 'provide' | 'finally' | 'recover' | 'invariant'
                    | 'decreases' | 'stream' | 'tensor' | 'affine'
                    | 'public' | 'internal' | 'protected' ;

(* Deprecated keywords - NOT used in Verum *)
deprecated_keywords = 'struct' | 'enum' | 'trait' | 'impl' ;

(* Composite keyword definition *)
keyword = reserved_keyword | primary_keyword | control_flow
        | async_keywords | modifiers | ffi_keywords
        | module_keywords | additional_keywords ;

(* 1.5 Literals *)

(* 1.5.1 Numeric Literals *)
dec_digit       = '0'..'9' ;
hex_digit       = dec_digit | 'a'..'f' | 'A'..'F' ;
bin_digit       = '0' | '1' ;

decimal_lit     = dec_digit , { dec_digit | '_' } ;
hexadecimal_lit = '0x' , hex_digit , { hex_digit | '_' } ;
binary_lit      = '0b' , bin_digit , { bin_digit | '_' } ;

integer_lit     = ( decimal_lit | hexadecimal_lit | binary_lit ) , [ '_' , identifier ] ;
float_lit       = decimal_lit , '.' , decimal_lit , [ exponent ] , [ '_' , identifier ] ;
exponent        = ( 'e' | 'E' ) , [ '+' | '-' ] , decimal_lit ;

(* 1.5.2 Text Literals - Fully Specified *)
string_char     = char_except_quote | ( '\' , char_except_backslash ) ;
char            = char_except_apostrophe | ( '\' , char_except_backslash ) ;

plain_string    = '"' , { string_char | escape_seq } , '"' ;
multiline_string= '"""' , { char_except_newline | '\n' | '\r\n' } , '"""' ;
raw_string      = 'r' , raw_string_delim ;
raw_string_delim= '#' , { '#' } , '"' , raw_string_content , '"' , '#' , { '#' } ;
raw_string_content = { char_except_quote } ;
string_lit      = plain_string | multiline_string | raw_string ;

tagged_literal  = identifier , '#' , ( plain_string | raw_string ) ;
interpolated_string = identifier , '"' , { string_char | interpolation } , '"' ;
interpolation   = '{' , expression , '}' ;

char_lit        = "'" , ( char | escape_seq ) , "'" ;

escape_seq      = '\' , ( 'n' | 'r' | 't' | '\' | '"' | "'"
                | 'x' , hex_digit , hex_digit
                | 'u' , '{' , hex_sequence , '}' ) ;
hex_sequence    = hex_digit | hex_digit , hex_sequence ;

(* 1.5.3 Boolean Literals *)
bool_lit        = 'true' | 'false' ;

(* 1.5.4 Revolutionary Literal Syntax - Fully Specified *)
context_adaptive_lit = bare_token ;
bare_token      = identifier | hex_color_literal | at_literal | dollar_literal ;
hex_color_literal = '#' , hex_digit , hex_digit , hex_digit
                  , hex_digit , hex_digit , hex_digit
                  , [ hex_digit , hex_digit ] ;
at_literal      = '@' , identifier ;
dollar_literal  = '$' , identifier ;

composite_literal = identifier , '#' , composite_body ;
composite_body  = composite_string | composite_paren | composite_bracket | composite_brace ;
composite_string = '"' , { char_except_quote } , '"' ;
composite_paren  = '(' , { composite_char } , ')' ;
composite_bracket = '[' , { composite_char } , ']' ;
composite_brace  = '{' , { composite_char } , '}' ;
composite_char  = char_except_newline - ( ')' | ']' | '}' ) ;

semantic_literal = semantic_tag , '#' , ( plain_string | raw_string ) ;
semantic_tag    = 'gql' | 'rx' | 'sql' | 'url' | 'email' | 'json' | 'xml' | 'yaml' | 'contract' ;

contract_literal = 'contract' , '#' , ( plain_string | raw_string ) ;

safe_interpolated = semantic_tag , '"' , { string_char | safe_interpolation } , '"' ;
safe_interpolation = '{' , expression , '}' ;

literal_expr    = integer_lit
                | float_lit
                | string_lit
                | char_lit
                | bool_lit
                | context_adaptive_lit
                | composite_literal
                | semantic_literal
                | contract_literal
                | tagged_literal
                | interpolated_string
                | safe_interpolated ;

(* 1.6 Operators and Punctuation *)
arith_op        = '+' | '-' | '*' | '/' | '%' | '**' ;
compare_op      = '==' | '!=' | '<' | '>' | '<=' | '>=' ;
logical_op      = '&&' | '||' | '!' ;
bitwise_op      = '&' | '|' | '^' | '<<' | '>>' | '~' ;
assign_op       = '=' | '+=' | '-=' | '*=' | '/=' | '%='
                | '&=' | '|=' | '^=' | '<<=' | '>>=' ;
range_op        = '..' | '..=' ;
pipe_op         = '|>' ;
compose_op      = '>>' | '<<' ;
arrow_op        = '->' | '=>' ;
optional_chain  = '?.' ;
null_coalesce   = '??' ;
punctuation     = '(' | ')' | '[' | ']' | '{' | '}'
                | '<' | '>' | ',' | ';' | ':' | '.' | '@'
                | '?' | '&' | '|' | '%' | '!' | '#' | '_' ;

(* ============================================================================ *)
(* 2. SYNTACTIC GRAMMAR                                                         *)
(* ============================================================================ *)

(* 2.1 Program Structure *)
program         = { program_item } ;

program_item    = item | statement ;

item            = function_def
                | type_def
                | impl_block
                | context_def
                | context_group_def
                | const_def
                | static_def
                | import_stmt
                | module_def
                | meta_def
                | ffi_declaration
                | attribute_item ;

visibility      = 'public' | 'internal' | 'protected' | epsilon ;
epsilon         = ;

attribute_item  = '@' , attribute , item ;
attribute       = identifier , [ '(' , attribute_args , ')' ] ;
attribute_args  = expression_list ;
expression_list = expression , { ',' , expression } ;

(* 2.2 Imports and Modules *)
import_stmt     = 'import' , import_tree , [ 'as' , identifier ] , ';' ;
import_tree     = path
                | path , '.' , '{' , import_list , '}'
                | path , '.' , '*' ;
import_list     = import_tree , { ',' , import_tree } ;

module_def      = visibility , 'module' , identifier , module_body ;
module_body     = '{' , { program_item } , '}' | ';' ;

path            = [ '.' ] , path_segment , { '.' , path_segment } ;
path_segment    = identifier | 'self' | 'super' | 'crate' ;

(* 2.3 Type Definitions - Unified 'is' syntax *)
type_def        = visibility , 'type' , [ 'affine' ] , identifier , [ generics ]
                , [ meta_where_clause ]
                , 'is' , type_definition_body ;

type_definition_body = type_expr , [ type_refinement ] , ';'
                     | identifier , ':' , type_expr , type_refinement , ';'
                     | '(' , type_list , ')' , ';'
                     | '{' , field_list , '}' , ';'
                     | variant_list , ';'
                     | 'protocol' , '{' , protocol_items , '}' , ';' ;

type_refinement = inline_refinement | value_where_clause ;

inline_refinement = '{' , refinement_predicates , '}' ;
refinement_predicates = refinement_predicate , { ',' , refinement_predicate } ;
refinement_predicate = identifier , ':' , expression | expression ;

declarative_refinement = 'where' , refinement_method ;
refinement_method = inline_refinement
                  | lambda_expr
                  | sigma_type
                  | predicate_name
                  | bare_expr ;

lambda_expr = '|' , param_list_lambda , '|' , expression ;
param_list_lambda = [ identifier , { ',' , identifier } ] ;

predicate_name = identifier ;
bare_expr = expression ;
predicate_expr = expression ;

sigma_type = identifier , ':' , type_expr , [ 'where' , expression ] ;

variant_list    = [ '|' ] , variant , { '|' , variant } ;
variant         = identifier , [ variant_data ] ;
variant_data    = '{' , field_list , '}' | '(' , type_list , ')' ;

field_list      = [ field , { ',' , field } , [ ',' ] ] ;
field           = [ visibility ] , identifier , ':' , type_expr ;

protocol_items  = { protocol_item } ;

(* 2.4 Functions *)
function_def    = visibility , function_modifiers , 'fn' , identifier
                , [ generics ] , '(' , param_list , ')'
                , [ '->' , type_expr , [ ensures_clause ] ]
                , [ whitespace_plus , context_clause ]
                , [ generic_where_clause ]
                , [ meta_where_clause ]
                , function_body ;

whitespace_plus = whitespace , { whitespace } ;

function_modifiers = [ 'meta' ] , [ 'async' ] , [ 'unsafe' ] | epsilon ;

context_clause  = 'using' , context_spec ;
context_spec    = single_context | context_list ;
single_context  = context_path ;
context_list    = '[' , context_path , { ',' , context_path } , ']' ;
context_path    = path , [ type_args ] ;

function_body   = block_expr | '=' , expression , ';' ;

param_list      = [ param , { ',' , param } , [ ',' ] ] ;
param           = param_pattern | self_param ;
param_pattern   = pattern , ':' , type_expr ;
self_param      = [ ref_modifier ] , 'self' ;
ref_modifier    = '&' , [ ref_kind ] , [ 'mut' ] ;
ref_kind        = 'checked' | 'unsafe' | epsilon ;

generics        = '<' , generic_params , '>' ;
generic_params  = generic_param , { ',' , generic_param } ;
generic_param   = type_param | meta_param ;

type_param      = identifier , [ ':' , bounds ] ;
meta_param      = identifier , ':' , 'meta' , type_expr , [ refinement ] ;
refinement      = '{' , predicate_expr , '}' ;

bounds          = bound , { '+' , bound } ;
bound           = protocol_bound ;
protocol_bound  = path_type ;

where_clause    = 'where' , where_predicates ;
where_predicates= where_predicate , { ',' , where_predicate } ;
where_predicate = type_expr , ':' , bounds | type_expr , '=' , type_expr ;

generic_where_clause = 'where' , 'type' , type_constraint_list ;
type_constraint_list = type_constraint , { ',' , type_constraint } ;
type_constraint      = identifier , ':' , protocol_bound ;

meta_where_clause    = 'where' , 'meta' , meta_constraint_list ;
meta_constraint_list = meta_constraint , { ',' , meta_constraint } ;
meta_constraint      = expression ;

value_where_clause   = 'where' , [ 'value' ] , refinement_expr ;
refinement_expr      = expression ;

ensures_clause       = 'where' , ensures_item , { ',' , ensures_item } ;
ensures_item         = 'ensures' , expression ;

(* 2.5 Protocol Implementations *)
protocol_item   = protocol_function | protocol_type | protocol_const ;
protocol_function = visibility , 'fn' , identifier , [ generics ]
                  , '(' , param_list , ')' , [ '->' , type_expr ]
                  , [ where_clause ] , [ default_impl ] ;
protocol_type   = 'type' , identifier , [ ':' , bounds ] , ';' ;
protocol_const  = 'const' , identifier , ':' , type_expr , ';' ;

default_impl    = block_expr | '=' , expression , ';' ;

impl_block      = 'implement' , [ generics ] , impl_type
                , [ where_clause ] , '{' , { impl_item } , '}' ;

impl_type       = type_expr , 'for' , type_expr | type_expr ;

impl_item       = visibility , ( function_def | type_alias | const_def ) ;

type_alias      = 'type' , identifier , [ generics ] , '=' , type_expr , ';' ;

(* 2.6 Context Definitions *)
context_def     = visibility , 'context' , identifier , [ generics ]
                , '{' , { context_item } , '}' ;

context_item    = context_function | context_type | context_const ;

context_function = visibility , 'fn' , identifier , [ generics ]
                 , '(' , param_list , ')' , [ '->' , type_expr ]
                 , [ where_clause ] , ';' ;

context_type    = 'type' , identifier , [ ':' , bounds ] , ';' ;
context_const   = 'const' , identifier , ':' , type_expr , ';' ;

context_group_def = 'using' , identifier , '=' , context_list_def , ';' ;
context_list_def  = '[' , identifier , { ',' , identifier } , ']' | identifier ;

(* 2.7 FFI Boundary Declarations *)
ffi_declaration = visibility , 'ffi' , identifier , [ 'extends' , identifier ] ,
                  '{' , ffi_items , '}' ;

ffi_items = { ffi_item } ;

ffi_item = ffi_function_decl
         | ffi_requires_clause
         | ffi_ensures_clause
         | ffi_memory_effects
         | ffi_thread_safety
         | ffi_error_protocol
         | ffi_ownership_spec ;

ffi_function_decl = '@extern' , '(' , string_lit , [ ',' , calling_convention_attr ] , ')' ,
                    'fn' , identifier , [ generics ] , '(' , param_list , ')' , [ '->' , type_expr ] , ';' ;

calling_convention_attr = 'calling_convention' , '=' , string_lit ;

ffi_requires_clause = 'requires' , expression , ';' ;
ffi_ensures_clause = 'ensures' , expression , ';' ;

ffi_memory_effects = 'memory_effects' , '=' , memory_effect_spec , ';' ;
memory_effect_spec = 'Pure'
                   | 'Reads' , '(' , path , ')'
                   | 'Writes' , '(' , path , ')'
                   | 'Allocates'
                   | 'Deallocates' , '(' , path , ')'
                   | memory_effect_spec , '+' , memory_effect_spec ;

ffi_thread_safety = 'thread_safe' , '=' , bool_lit , ';' ;

ffi_error_protocol = 'errors_via' , '=' , error_mechanism , ';' ;
error_mechanism   = 'None'
                  | 'Errno'
                  | 'ReturnCode' , '(' , pattern , ')'
                  | 'ReturnValue' , '(' , expression , ')' , [ 'with' , 'Errno' ]
                  | 'Exception' ;

ffi_ownership_spec = '@ownership' , '(' , ownership_mode , ')' ;
ownership_mode    = 'transfer_to' , '=' , string_lit
                  | 'transfer_from' , '=' , string_lit
                  | 'borrow'
                  | 'shared' ;

(* 2.8 Types *)
type_expr       = simple_type , [ type_refinement ] ;

simple_type     = primitive_type
                | path_type
                | tuple_type
                | array_type
                | slice_type
                | managed_reference_type
                | checked_reference_type
                | unsafe_reference_type
                | pointer_type
                | function_type
                | generic_type
                | inferred_type
                | dynamic_type ;

primitive_type  = 'Int' | 'Float' | 'Bool' | 'Char' | 'Text' | '()' ;
path_type       = path ;
tuple_type      = '(' , type_expr , { ',' , type_expr } , ')' ;
array_type      = '[' , type_expr , ';' , expression , ']' ;
slice_type      = '[' , type_expr , ']' ;

managed_reference_type = '&' , [ 'mut' ] , type_expr ;
checked_reference_type = '&' , 'checked' , [ 'mut' ] , type_expr ;
unsafe_reference_type = '&' , 'unsafe' , [ 'mut' ] , type_expr ;

pointer_type    = '*' , ( 'const' | 'mut' ) , type_expr ;
function_type   = 'fn' , '(' , type_list , ')' , [ '->' , type_expr ] ;

generic_type    = path , type_args ;
type_args       = '<' , type_arg , { ',' , type_arg } , '>' ;
type_arg        = type_expr | expression ;

inferred_type   = '_' ;

dynamic_type    = 'dyn' , protocol_bounds , [ associated_type_bindings ] ;

protocol_bounds = protocol_bound , { '+' , protocol_bound } ;

associated_type_bindings = '<' , type_binding , { ',' , type_binding } , [ ',' ] , '>' ;
type_binding    = identifier , '=' , type_expr ;

type_list       = [ type_expr , { ',' , type_expr } ] ;

(* 2.10 Expressions *)
expression      = pipeline_expr ;

pipeline_expr   = assignment_expr , { '|>' , assignment_expr } ;

assignment_expr = null_coalesce_expr , [ assign_op , assignment_expr ] ;

null_coalesce_expr = range_expr , { '??' , range_expr } ;

range_expr      = logical_or_expr , [ range_op , logical_or_expr ] ;

logical_or_expr = logical_and_expr , { '||' , logical_and_expr } ;
logical_and_expr= equality_expr , { '&&' , equality_expr } ;

equality_expr   = relational_expr , { ( '==' | '!=' ) , relational_expr } ;
relational_expr = bitwise_expr , { ( '<' | '>' | '<=' | '>=' ) , bitwise_expr } ;

bitwise_expr    = shift_expr , { ( '&' | '|' | '^' ) , shift_expr } ;
shift_expr      = additive_expr , { ( '<<' | '>>' ) , additive_expr } ;

additive_expr   = mult_expr , { ( '+' | '-' ) , mult_expr } ;
mult_expr       = power_expr , { ( '*' | '/' | '%' ) , power_expr } ;
power_expr      = unary_expr , [ '**' , power_expr ] ;

unary_expr      = unary_op , unary_expr | postfix_expr ;
unary_op        = '!' | '-' | '~' | '&' | '&' , 'mut'
                | '&' , 'checked' | '&' , 'checked' , 'mut'
                | '&' , 'unsafe' | '&' , 'unsafe' , 'mut' | '*' ;

postfix_expr    = primary_expr , { postfix_op } ;
postfix_op      = '.' , identifier , [ call_args ]
                | '?.' , identifier , [ call_args ]
                | '.' , integer_lit
                | '.' , 'await'
                | '[' , expression , ']'
                | call_args
                | '?'
                | 'as' , type_expr ;

call_args       = '(' , arg_list , ')' ;
arg_list        = [ expression , { ',' , expression } , [ ',' ] ] ;

(* 2.11 Stream Processing Syntax *)
stream_comprehension_expr = 'stream' , '[' , stream_body , ']' ;

stream_body     = expression , 'for' , pattern , 'in' , expression
                , { stream_clause } ;

stream_clause   = 'for' , pattern , 'in' , expression
                | 'let' , pattern , [ ':' , type_expr ] , '=' , expression
                | 'if' , expression ;

(* 2.12 Primary Expressions *)
primary_expr    = literal_expr
                | path_expr
                | '(' , expression , ')'
                | tuple_expr
                | array_expr
                | tensor_literal_expr
                | map_expr
                | set_expr
                | comprehension_expr
                | stream_comprehension_expr
                | record_expr
                | block_expr
                | if_expr
                | match_expr
                | loop_expr
                | try_expr
                | closure_expr
                | meta_expr
                | async_expr
                | unsafe_expr
                | return_expr
                | break_expr
                | continue_expr
                | spawn_expr
                | yield_expr ;

path_expr       = path ;

tuple_expr      = '(' , expression , { ',' , expression } , ')' ;

array_expr      = '[' , array_elements , ']' ;
array_elements  = expression_list | expression , ';' , expression ;

tensor_literal_expr = 'tensor' , '<' , shape_params , '>' , type_expr , '{' , tensor_elements , '}' ;
shape_params    = expression_list ;
tensor_elements = expression_list | nested_array_elements | expression ;
nested_array_elements = '{' , expression_list , '}' , { ',' , '{' , expression_list , '}' } ;

map_expr        = '{' , [ map_entries ] , '}' ;
map_entries     = map_entry , { ',' , map_entry } ;
map_entry       = expression , ':' , expression ;

set_expr        = '{' , [ expression_list ] , '}' ;

comprehension_expr = '[' , expression , 'for' , pattern , 'in' , expression
                   , { comprehension_clause } , ']' ;

comprehension_clause = 'for' , pattern , 'in' , expression
                     | 'if' , expression ;

record_expr     = path , '{' , field_inits , '}' ;
field_inits     = [ field_init , { ',' , field_init } , [ '..' , expression ] ] ;
field_init      = identifier , [ ':' , expression ] ;

block_expr      = '{' , { statement } , [ expression ] , '}' ;

if_expr         = 'if' , if_condition , block_expr
                , [ 'else' , ( if_expr | block_expr ) ] ;

if_condition    = let_condition , { '&&' , let_condition } ;
let_condition   = 'let' , pattern , '=' , expression | expression ;

match_expr      = [ expression , '.' ] , 'match' , [ expression ] , '{' , match_arms , '}' ;
match_arms      = [ match_arm , { ',' , match_arm } , [ ',' ] ] ;
match_arm       = pattern , [ guard ] , '=>' , expression ;
guard           = 'if' , expression ;

loop_expr       = infinite_loop | while_loop | for_loop ;
infinite_loop   = 'loop' , block_expr ;
while_loop      = 'while' , expression , { loop_annotation } , block_expr ;
for_loop        = 'for' , pattern , 'in' , expression , { loop_annotation } , block_expr ;

loop_annotation = 'invariant' , expression | 'decreases' , expression ;

closure_expr    = [ 'async' ] , closure_params , [ '->' , type_expr ] , expression ;
closure_params  = '|' , [ param_list_lambda ] , '|' ;

async_expr      = 'async' , block_expr ;

unsafe_expr     = 'unsafe' , block_expr ;

meta_expr       = 'meta' , block_expr ;

try_expr        = 'try' , block_expr , [ try_handlers ] ;
try_handlers    = try_recovery , [ try_finally ]
                | try_finally ;
try_recovery    = 'recover' , '{' , match_arms , '}' ;
try_finally     = 'finally' , block_expr ;

return_expr     = 'return' , [ expression ] ;
break_expr      = 'break' , [ expression ] ;
continue_expr   = 'continue' ;
spawn_expr      = 'spawn' , expression ;
yield_expr      = 'yield' , expression ;

(* 2.13 Statements *)
statement       = let_stmt
                | let_else_stmt
                | provide_stmt
                | item
                | defer_stmt
                | expression_stmt ;

let_stmt        = 'let' , pattern , [ ':' , type_expr ] , [ '=' , expression ] , ';' ;

let_else_stmt   = 'let' , pattern , '=' , expression , 'else' , block_expr ;

provide_stmt    = 'provide' , identifier , '=' , expression , ';' ;

defer_stmt      = 'defer' , ( expression , ';' | block_expr ) ;

expression_stmt = expression , [ ';' ] ;

(* 2.14 Patterns *)
pattern         = or_pattern ;

or_pattern      = and_pattern , { '|' , and_pattern } ;

and_pattern     = simple_pattern ;

simple_pattern  = literal_pattern
                | identifier_pattern
                | wildcard_pattern
                | rest_pattern
                | tuple_pattern
                | array_pattern
                | slice_pattern
                | record_pattern
                | variant_pattern
                | reference_pattern
                | range_pattern ;

literal_pattern = literal_expr ;

identifier_pattern = [ 'ref' ] , [ 'mut' ] , identifier , [ '@' , pattern ] ;

wildcard_pattern = '_' ;

rest_pattern    = '..' ;

tuple_pattern   = '(' , pattern_list , ')' ;

array_pattern   = '[' , pattern_list , ']' ;

slice_pattern   = '[' , slice_pattern_elements , ']' ;
slice_pattern_elements = [ pattern , { ',' , pattern } , ',' ] , '..'
                       , [ ',' , pattern , { ',' , pattern } ] ;

record_pattern  = path , '{' , field_patterns , '}' ;
field_patterns  = [ field_pattern , { ',' , field_pattern } , [ ',' , '..' ] ] ;
field_pattern   = identifier , [ ':' , pattern ] ;

variant_pattern = path , [ variant_pattern_data ] ;
variant_pattern_data = '(' , pattern_list , ')'
                     | '{' , field_patterns , '}' ;

reference_pattern = '&' , [ 'mut' ] , pattern ;

range_pattern   = literal_expr , range_op , [ literal_expr ]
                | range_op , literal_expr ;

pattern_list    = [ pattern , { ',' , pattern } , [ ',' ] ] ;

(* 2.15 Constants and Statics *)
const_def       = visibility , 'const' , identifier , ':' , type_expr
                , '=' , const_expr , ';' ;
static_def      = visibility , 'static' , [ 'mut' ] , identifier
                , ':' , type_expr , '=' , const_expr , ';' ;

const_expr      = expression ;

(* 2.16 Metaprogramming *)
meta_def        = visibility , 'meta' , identifier , meta_args
                , '{' , meta_rules , '}' ;

meta_args       = '(' , [ meta_params_meta ] , ')' ;
meta_params_meta= meta_param_def , { ',' , meta_param_def } ;
meta_param_def  = identifier , [ ':' , meta_fragment ] ;

meta_fragment   = 'expr' | 'stmt' | 'type' | 'pattern' | 'ident'
                | 'path' | 'tt' | 'item' | 'block' ;

meta_rules      = meta_rule , { '|' , meta_rule } ;
meta_rule       = pattern , '=>' , expression ;

meta_call       = path , '!' , meta_call_args ;
meta_call_args  = '(' , token_tree , ')'
                | '[' , token_tree , ']'
                | '{' , token_tree , '}' ;

token_tree      = { token_tree_elem } ;
token_tree_elem = token | '(' , token_tree , ')'
                | '[' , token_tree , ']'
                | '{' , token_tree , '}' ;

token           = identifier | keyword | literal_expr | operator | punctuation ;
operator        = arith_op | compare_op | logical_op | bitwise_op
                | assign_op | range_op | pipe_op | compose_op
                | arrow_op | optional_chain | null_coalesce ;

(* ============================================================================ *)
(* 3. ERROR RECOVERY                                                            *)
(* ============================================================================ *)

(* Error Recovery Points - Parser Implementation Guidance *)
error_recovery  = synchronize_on_semicolon
                | synchronize_on_brace
                | synchronize_on_keyword
                | insert_missing_delimiter
                | skip_invalid_tokens ;

(* Synchronization strategies *)
synchronize_on_semicolon = { token - ';' } , ';' ;
synchronize_on_brace     = { token - '}' } , '}' ;
synchronize_on_keyword   = { token - keyword } , keyword ;

(* Automatic insertion for common errors *)
insert_missing_delimiter = insert_semicolon | insert_closing_brace | insert_closing_paren ;
insert_semicolon     = /* Parser inserts ';' when expected but missing */ ;
insert_closing_brace = /* Parser inserts '}' when expected but missing */ ;
insert_closing_paren = /* Parser inserts ')' when expected but missing */ ;

(* Token skipping for invalid input *)
skip_invalid_tokens = { token - ( ';' | '}' | keyword ) } ;

(* Common error patterns with recovery *)
missing_semicolon_error = 'let' , pattern , [ ':' , type_expr ] , '=' , expression
                        , { token - ( ';' | '}' | keyword ) } ;

unclosed_delimiter_error = '(' , { token - ')' } , end_of_file
                         | '[' , { token - ']' } , end_of_file
                         | '{' , { token - '}' } , end_of_file ;

end_of_file = /* End of input stream */ ;

(* ============================================================================ *)
(* End of Grammar                                                               *)
(* ============================================================================ *)